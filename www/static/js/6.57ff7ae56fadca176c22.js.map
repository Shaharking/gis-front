{"version":3,"sources":["webpack:///static/js/6.57ff7ae56fadca176c22.js","webpack:///./src/views/Map.vue?8a32","webpack:///./src/views/Map.vue","webpack:///./~/leaflet.locatecontrol/dist/L.Control.Locate.css","webpack:///./src/views/Map.vue?24c1","webpack:///./src/views/Map.vue?28d7","webpack:///./~/leaflet.locatecontrol/src/L.Control.Locate.js","webpack:///./src/views/Map.vue?ea99"],"names":["webpackJsonp","366","module","exports","__webpack_require__","Component","452","__webpack_exports__","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default","n","__WEBPACK_IMPORTED_MODULE_1_vuex__","__WEBPACK_IMPORTED_MODULE_2_leaflet_locatecontrol__","__WEBPACK_IMPORTED_MODULE_2_leaflet_locatecontrol___default","data","zoom","minZoom","maxZoom","url","attribution","title","opacity","draggable","attributionControl","computed","i","mounted","this","SET_TITLE","$t","SET_RIGHT_OPTION","show","name","link","addControl","a","methods","469","push","version","sources","names","mappings","file","sourcesContent","sourceRoot","481","496","content","locals","499","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","window","undefined","apply","L","Control","Locate","LocateControl","extend","options","position","layer","setView","keepCurrentZoomLevel","flyTo","clickBehavior","inView","outOfView","returnToPrevBounds","cacheLocation","drawCircle","drawMarker","markerClass","CircleMarker","circleStyle","color","fillColor","fillOpacity","weight","markerStyle","radius","followCircleStyle","followMarkerStyle","icon","iconLoading","iconElementTag","circlePadding","metric","onLocationError","err","control","alert","message","onLocationOutsideMapBounds","stop","strings","outsideMapBoundsMsg","showPopup","metersUnit","feetUnit","popup","locateOptions","Infinity","watch","initialize","onAdd","map","container","DomUtil","create","_layer","LayerGroup","addTo","_event","_prevBounds","_link","_icon","DomEvent","on","stopPropagation","preventDefault","_onClick","_resetVariables","_map","_unload","_justClicked","_userPanned","_active","behavior","getBounds","contains","latlng","f","flyToBounds","fitBounds","bind","start","_updateContainerStyle","_activate","_drawMarker","_deactivate","_cleanClasses","_removeMarker","locate","_onLocationFound","_onLocationError","_onDrag","stopLocate","off","_isOutsideMapBounds","panTo","latitude","longitude","bounds","padding","accuracy","style","_isFollowing","_circle","setLatLng","setRadius","setStyle","circle","distance","unit","toFixed","mStyle","_marker","t","bindPopup","Util","template","_popup","clearLayers","code","e","lat","lng","maxBounds","_container","_setClasses","state","removeClasses","addClasses","removeClass","LDomUtilApplyClassesMethod","method","element","classNames","split","forEach","className","call","el","565","render","_vm","_h","$createElement","_c","_self","staticClass","attrs","center","min-zoom","max-zoom","_v","cityName","staticRenderFns"],"mappings":"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","file":"static/js/6.57ff7ae56fadca176c22.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 366:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(496)\n\nvar Component = __webpack_require__(14)(\n  /* script */\n  __webpack_require__(452),\n  /* template */\n  __webpack_require__(565),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 452:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(151);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuex__ = __webpack_require__(50);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_leaflet_locatecontrol__ = __webpack_require__(499);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_leaflet_locatecontrol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_leaflet_locatecontrol__);\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            zoom: 9,\n            minZoom: 1,\n            maxZoom: 18,\n            url: 'http://{s}.tile.osm.org/{z}/{x}/{y}.png',\n            attribution: 'brandon.xiang',\n            title: 'test-marker',\n            opacity: 1,\n            draggable: false,\n            attributionControl: false\n        };\n    },\n\n\n    computed: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_vuex__[\"b\" /* mapGetters */])(['center', 'cityName'])),\n\n    mounted: function mounted() {\n        this.SET_TITLE(this.$t('Map'));\n        this.SET_RIGHT_OPTION({ show: true, name: '城市', link: 'cities/map' });\n        this.addControl(new __WEBPACK_IMPORTED_MODULE_2_leaflet_locatecontrol___default.a());\n    },\n\n\n    methods: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_vuex__[\"c\" /* mapMutations */])(['SET_TITLE', 'SET_RIGHT_OPTION', 'addControl']))\n});\n\n/***/ }),\n\n/***/ 469:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(361)(true);\n// imports\n\n\n// module\nexports.push([module.i, \".leaflet-control-locate a{font-size:1.4em;color:#444;cursor:pointer}.leaflet-control-locate.active a{color:#2074b6}.leaflet-control-locate.active.following a{color:#fc8428}\", \"\", {\"version\":3,\"sources\":[\"/Users/brandonxiang/github/vue-leaflet-mobile/node_modules/leaflet.locatecontrol/dist/L.Control.Locate.css\"],\"names\":[],\"mappings\":\"AACA,0BACE,gBAAiB,AACjB,WAAY,AACZ,cAAgB,CACjB,AACD,iCACE,aAAe,CAChB,AACD,2CACE,aAAe,CAChB\",\"file\":\"L.Control.Locate.css\",\"sourcesContent\":[\"/* Compatible with Leaflet 0.7 */\\n.leaflet-control-locate a {\\n  font-size: 1.4em;\\n  color: #444;\\n  cursor: pointer;\\n}\\n.leaflet-control-locate.active a {\\n  color: #2074B6;\\n}\\n.leaflet-control-locate.active.following a {\\n  color: #FC8428;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 481:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(361)(true);\n// imports\nexports.push([module.i, \"@import url(https://cdn.bootcss.com/leaflet/1.0.3/leaflet.css);\", \"\"]);\nexports.i(__webpack_require__(469), \"\");\nexports.push([module.i, \"@import url(//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css);\", \"\"]);\n\n// module\nexports.push([module.i, \"#map{width:100%;height:100%}\", \"\", {\"version\":3,\"sources\":[\"/Users/brandonxiang/github/vue-leaflet-mobile/src/views/Map.vue\"],\"names\":[],\"mappings\":\"AAIA,KACI,WAAY,AACZ,WAAa,CAChB\",\"file\":\"Map.vue\",\"sourcesContent\":[\"\\n@import \\\"https://cdn.bootcss.com/leaflet/1.0.3/leaflet.css\\\";\\n@import \\\"~leaflet.locatecontrol/dist/L.Control.Locate.css\\\";\\n@import \\\"//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css\\\";\\n#map {\\n    width: 100%;\\n    height: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 496:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(481);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(362)(\"5857b9b2\", content, true);\n\n/***/ }),\n\n/***/ 499:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n(function (factory, window) {\n     // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders\n     // for details on how to structure a leaflet plugin.\n\n    // define an AMD module that relies on 'leaflet'\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(158)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        if (typeof window !== 'undefined' && window.L) {\n            module.exports = factory(L);\n        } else {\n            module.exports = factory(require('leaflet'));\n        }\n    }\n\n    // attach your plugin to the global 'L' variable\n    if (typeof window !== 'undefined' && window.L){\n        window.L.Control.Locate = factory(L);\n    }\n} (function (L) {\n    var LocateControl = L.Control.extend({\n        options: {\n            /** Position of the control */\n            position: 'topleft',\n            /** The layer that the user's location should be drawn on. By default creates a new layer. */\n            layer: undefined,\n            /**\n             * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n             * While the map is following the user's location, the control is in the `following` state,\n             * which changes the style of the control and the circle marker.\n             *\n             * Possible values:\n             *  - false: never updates the map view when location changes.\n             *  - 'once': set the view when the location is first determined\n             *  - 'always': always updates the map view when location changes.\n             *              The map view follows the users location.\n             *  - 'untilPan': (default) like 'always', except stops updating the\n             *                view if the user has manually panned the map.\n             *                The map view follows the users location until she pans.\n             */\n            setView: 'untilPan',\n            /** Keep the current map zoom level when setting the view and only pan. */\n            keepCurrentZoomLevel: false,\n            /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n            flyTo: false,\n            /**\n             * The user location can be inside and outside the current view when the user clicks on the\n             * control that is already active. Both cases can be configures separately.\n             * Possible values are:\n             *  - 'setView': zoom and pan to the current location\n             *  - 'stop': stop locating and remove the location marker\n             */\n            clickBehavior: {\n                /** What should happen if the user clicks on the control while the location is within the current view. */\n                inView: 'stop',\n                /** What should happen if the user clicks on the control while the location is outside the current view. */\n                outOfView: 'setView',\n            },\n            /**\n             * If set, save the map bounds just before centering to the user's\n             * location. When control is disabled, set the view back to the\n             * bounds that were saved.\n             */\n            returnToPrevBounds: false,\n            /**\n             * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n             * until the locate API returns a new location before they see where they are again.\n             */\n            cacheLocation: true,\n            /** If set, a circle that shows the location accuracy is drawn. */\n            drawCircle: true,\n            /** If set, the marker at the users' location is drawn. */\n            drawMarker: true,\n            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n            markerClass: L.CircleMarker,\n            /** Accuracy circle style properties. */\n            circleStyle: {\n                color: '#136AEC',\n                fillColor: '#136AEC',\n                fillOpacity: 0.15,\n                weight: 2,\n                opacity: 0.5\n            },\n            /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n            markerStyle: {\n                color: '#136AEC',\n                fillColor: '#2A93EE',\n                fillOpacity: 0.7,\n                weight: 2,\n                opacity: 0.9,\n                radius: 5\n            },\n            /**\n             * Changes to accuracy circle and inner marker while following.\n             * It is only necessary to provide the properties that should change.\n             */\n            followCircleStyle: {},\n            followMarkerStyle: {\n                // color: '#FFA500',\n                // fillColor: '#FFB000'\n            },\n            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n            icon: 'fa fa-map-marker',\n            iconLoading: 'fa fa-spinner fa-spin',\n            /** The element to be created for icons. For example span or i */\n            iconElementTag: 'span',\n            /** Padding around the accuracy circle. */\n            circlePadding: [0, 0],\n            /** Use metric units. */\n            metric: true,\n            /** This event is called in case of any location error that is not a time out error. */\n            onLocationError: function(err, control) {\n                alert(err.message);\n            },\n            /**\n             * This even is called when the user's location is outside the bounds set on the map.\n             * The event is called repeatedly when the location changes.\n             */\n            onLocationOutsideMapBounds: function(control) {\n                control.stop();\n                alert(control.options.strings.outsideMapBoundsMsg);\n            },\n            /** Display a pop-up when the user click on the inner marker. */\n            showPopup: true,\n            strings: {\n                title: \"Show me where I am\",\n                metersUnit: \"meters\",\n                feetUnit: \"feet\",\n                popup: \"You are within {distance} {unit} from this point\",\n                outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n            },\n            /** The default options passed to leaflets locate method. */\n            locateOptions: {\n                maxZoom: Infinity,\n                watch: true,  // if you overwrite this, visualization cannot be updated\n                setView: false // have to set this to false because we have to\n                               // do setView manually\n            }\n        },\n\n        initialize: function (options) {\n            // set default options if nothing is set (merge one step deep)\n            for (var i in options) {\n                if (typeof this.options[i] === 'object') {\n                    L.extend(this.options[i], options[i]);\n                } else {\n                    this.options[i] = options[i];\n                }\n            }\n\n            // extend the follow marker style and circle from the normal style\n            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);\n        },\n\n        /**\n         * Add control to map. Returns the container for the control.\n         */\n        onAdd: function (map) {\n            var container = L.DomUtil.create('div',\n                'leaflet-control-locate leaflet-bar leaflet-control');\n\n            this._layer = this.options.layer || new L.LayerGroup();\n            this._layer.addTo(map);\n            this._event = undefined;\n            this._prevBounds = null;\n\n            this._link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);\n            this._link.title = this.options.strings.title;\n            this._icon = L.DomUtil.create(this.options.iconElementTag, this.options.icon, this._link);\n\n            L.DomEvent\n                .on(this._link, 'click', L.DomEvent.stopPropagation)\n                .on(this._link, 'click', L.DomEvent.preventDefault)\n                .on(this._link, 'click', this._onClick, this)\n                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);\n\n            this._resetVariables();\n\n            this._map.on('unload', this._unload, this);\n\n            return container;\n        },\n\n        /**\n         * This method is called when the user clicks on the control.\n         */\n        _onClick: function() {\n            this._justClicked = true;\n            this._userPanned = false;\n\n            if (this._active && !this._event) {\n                // click while requesting\n                this.stop();\n            } else if (this._active && this._event !== undefined) {\n                var behavior = this._map.getBounds().contains(this._event.latlng) ?\n                    this.options.clickBehavior.inView : this.options.clickBehavior.outOfView;\n                switch (behavior) {\n                    case 'setView':\n                        this.setView();\n                        break;\n                    case 'stop':\n                        this.stop();\n                        if (this.options.returnToPrevBounds) {\n                            var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n                            f.bind(this._map)(this._prevBounds);\n                        }\n                        break;\n                }\n            } else {\n                if (this.options.returnToPrevBounds) {\n                  this._prevBounds = this._map.getBounds();\n                }\n                this.start();\n            }\n\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Starts the plugin:\n         * - activates the engine\n         * - draws the marker (if coordinates available)\n         */\n        start: function() {\n            this._activate();\n\n            if (this._event) {\n                this._drawMarker(this._map);\n\n                // if we already have a location but the user clicked on the control\n                if (this.options.setView) {\n                    this.setView();\n                }\n            }\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Stops the plugin:\n         * - deactivates the engine\n         * - reinitializes the button\n         * - removes the marker\n         */\n        stop: function() {\n            this._deactivate();\n\n            this._cleanClasses();\n            this._resetVariables();\n\n            this._removeMarker();\n        },\n\n        /**\n         * This method launches the location engine.\n         * It is called before the marker is updated,\n         * event if it does not mean that the event will be ready.\n         *\n         * Override it if you want to add more functionalities.\n         * It should set the this._active to true and do nothing if\n         * this._active is true.\n         */\n        _activate: function() {\n            if (!this._active) {\n                this._map.locate(this.options.locateOptions);\n                this._active = true;\n\n                // bind event listeners\n                this._map.on('locationfound', this._onLocationFound, this);\n                this._map.on('locationerror', this._onLocationError, this);\n                this._map.on('dragstart', this._onDrag, this);\n            }\n        },\n\n        /**\n         * Called to stop the location engine.\n         *\n         * Override it to shutdown any functionalities you added on start.\n         */\n        _deactivate: function() {\n            this._map.stopLocate();\n            this._active = false;\n\n            if (!this.options.cacheLocation) {\n                this._event = undefined;\n            }\n\n            // unbind event listeners\n            this._map.off('locationfound', this._onLocationFound, this);\n            this._map.off('locationerror', this._onLocationError, this);\n            this._map.off('dragstart', this._onDrag, this);\n        },\n\n        /**\n         * Zoom (unless we should keep the zoom level) and an to the current view.\n         */\n        setView: function() {\n            this._drawMarker();\n            if (this._isOutsideMapBounds()) {\n                this._event = undefined;  // clear the current location so we can get back into the bounds\n                this.options.onLocationOutsideMapBounds(this);\n            } else {\n                if (this.options.keepCurrentZoomLevel) {\n                    var f = this.options.flyTo ? this._map.flyTo : this._map.panTo;\n                    f.bind(this._map)([this._event.latitude, this._event.longitude]);\n                } else {\n                    var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n                    f.bind(this._map)(this._event.bounds, {\n                        padding: this.options.circlePadding,\n                        maxZoom: this.options.locateOptions.maxZoom\n                    });\n                }\n            }\n        },\n\n        /**\n         * Draw the marker and accuracy circle on the map.\n         *\n         * Uses the event retrieved from onLocationFound from the map.\n         */\n        _drawMarker: function() {\n            if (this._event.accuracy === undefined) {\n                this._event.accuracy = 0;\n            }\n\n            var radius = this._event.accuracy;\n            var latlng = this._event.latlng;\n\n            // circle with the radius of the location's accuracy\n            if (this.options.drawCircle) {\n                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n                if (!this._circle) {\n                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);\n                } else {\n                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n                }\n            }\n\n            var distance, unit;\n            if (this.options.metric) {\n                distance = radius.toFixed(0);\n                unit =  this.options.strings.metersUnit;\n            } else {\n                distance = (radius * 3.2808399).toFixed(0);\n                unit = this.options.strings.feetUnit;\n            }\n\n            // small inner marker\n            if (this.options.drawMarker) {\n                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n                if (!this._marker) {\n                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n                } else {\n                    this._marker.setLatLng(latlng);\n                    // If the markerClass can be updated with setStyle, update it.\n                    if (this._marker.setStyle) {\n                        this._marker.setStyle(mStyle);\n                    }\n                }\n            }\n\n            var t = this.options.strings.popup;\n            if (this.options.showPopup && t && this._marker) {\n                this._marker\n                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))\n                    ._popup.setLatLng(latlng);\n            }\n        },\n\n        /**\n         * Remove the marker from map.\n         */\n        _removeMarker: function() {\n            this._layer.clearLayers();\n            this._marker = undefined;\n            this._circle = undefined;\n        },\n\n        /**\n         * Unload the plugin and all event listeners.\n         * Kind of the opposite of onAdd.\n         */\n        _unload: function() {\n            this.stop();\n            this._map.off('unload', this._unload, this);\n        },\n\n        /**\n         * Calls deactivate and dispatches an error.\n         */\n        _onLocationError: function(err) {\n            // ignore time out error if the location is watched\n            if (err.code == 3 && this.options.locateOptions.watch) {\n                return;\n            }\n\n            this.stop();\n            this.options.onLocationError(err, this);\n        },\n\n        /**\n         * Stores the received event and updates the marker.\n         */\n        _onLocationFound: function(e) {\n            // no need to do anything if the location has not changed\n            if (this._event &&\n                (this._event.latlng.lat === e.latlng.lat &&\n                 this._event.latlng.lng === e.latlng.lng &&\n                     this._event.accuracy === e.accuracy)) {\n                return;\n            }\n\n            if (!this._active) {\n                // we may have a stray event\n                return;\n            }\n\n            this._event = e;\n\n            this._drawMarker();\n            this._updateContainerStyle();\n\n            switch (this.options.setView) {\n                case 'once':\n                    if (this._justClicked) {\n                        this.setView();\n                    }\n                    break;\n                case 'untilPan':\n                    if (!this._userPanned) {\n                        this.setView();\n                    }\n                    break;\n                case 'always':\n                    this.setView();\n                    break;\n                case false:\n                    // don't set the view\n                    break;\n            }\n\n            this._justClicked = false;\n        },\n\n        /**\n         * When the user drags. Need a separate even so we can bind and unbind even listeners.\n         */\n        _onDrag: function() {\n            // only react to drags once we have a location\n            if (this._event) {\n                this._userPanned = true;\n                this._updateContainerStyle();\n                this._drawMarker();\n            }\n        },\n\n        /**\n         * Compute whether the map is following the user location with pan and zoom.\n         */\n        _isFollowing: function() {\n            if (!this._active) {\n                return false;\n            }\n\n            if (this.options.setView === 'always') {\n                return true;\n            } else if (this.options.setView === 'untilPan') {\n                return !this._userPanned;\n            }\n        },\n\n        /**\n         * Check if location is in map bounds\n         */\n        _isOutsideMapBounds: function() {\n            if (this._event === undefined) {\n                return false;\n            }\n            return this._map.options.maxBounds &&\n                !this._map.options.maxBounds.contains(this._event.latlng);\n        },\n\n        /**\n         * Toggles button class between following and active.\n         */\n        _updateContainerStyle: function() {\n            if (!this._container) {\n                return;\n            }\n\n            if (this._active && !this._event) {\n                // active but don't have a location yet\n                this._setClasses('requesting');\n            } else if (this._isFollowing()) {\n                this._setClasses('following');\n            } else if (this._active) {\n                this._setClasses('active');\n            } else {\n                this._cleanClasses();\n            }\n        },\n\n        /**\n         * Sets the CSS classes for the state.\n         */\n        _setClasses: function(state) {\n            if (state == 'requesting') {\n                L.DomUtil.removeClasses(this._container, \"active following\");\n                L.DomUtil.addClasses(this._container, \"requesting\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.icon);\n                L.DomUtil.addClasses(this._icon, this.options.iconLoading);\n            } else if (state == 'active') {\n                L.DomUtil.removeClasses(this._container, \"requesting following\");\n                L.DomUtil.addClasses(this._container, \"active\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            } else if (state == 'following') {\n                L.DomUtil.removeClasses(this._container, \"requesting\");\n                L.DomUtil.addClasses(this._container, \"active following\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            }\n        },\n\n        /**\n         * Removes all classes from button.\n         */\n        _cleanClasses: function() {\n            L.DomUtil.removeClass(this._container, \"requesting\");\n            L.DomUtil.removeClass(this._container, \"active\");\n            L.DomUtil.removeClass(this._container, \"following\");\n\n            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n            L.DomUtil.addClasses(this._icon, this.options.icon);\n        },\n\n        /**\n         * Reinitializes state variables.\n         */\n        _resetVariables: function() {\n            // whether locate is active or not\n            this._active = false;\n\n            // true if the control was clicked for the first time\n            // we need this so we can pan and zoom once we have the location\n            this._justClicked = false;\n\n            // true if the user has panned the map after clicking the control\n            this._userPanned = false;\n        }\n    });\n\n    L.control.locate = function (options) {\n        return new L.Control.Locate(options);\n    };\n\n    (function(){\n      // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once\n      // Let's create a wrapper on it which fixes it.\n      var LDomUtilApplyClassesMethod = function(method, element, classNames) {\n        classNames = classNames.split(' ');\n        classNames.forEach(function(className) {\n            L.DomUtil[method].call(this, element, className);\n        });\n      };\n\n      L.DomUtil.addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };\n      L.DomUtil.removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };\n    })();\n\n    return LocateControl;\n}, window));\n\n\n/***/ }),\n\n/***/ 565:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"full-height\"\n  }, [_c('l-map', {\n    attrs: {\n      \"zoom\": _vm.zoom,\n      \"center\": _vm.center,\n      \"min-zoom\": _vm.minZoom,\n      \"max-zoom\": _vm.maxZoom,\n      \"attributionControl\": _vm.attributionControl\n    }\n  }, [_c('l-tilelayer', {\n    attrs: {\n      \"url\": _vm.url,\n      \"attribution\": _vm.attribution\n    }\n  }), _vm._v(\" \"), _c('l-marker', {\n    attrs: {\n      \"position\": _vm.center,\n      \"title\": _vm.$t(_vm.cityName),\n      \"opacity\": _vm.opacity,\n      \"draggable\": _vm.draggable\n    }\n  }, [_c('l-popup', {\n    attrs: {\n      \"content\": _vm.$t(_vm.cityName)\n    }\n  })], 1)], 1)], 1)\n},staticRenderFns: []}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/6.57ff7ae56fadca176c22.js","\n/* styles */\nrequire(\"!!../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"id\\\":\\\"data-v-e61a7770\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!./../../node_modules/vux-loader/src/style-loader.js!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./Map.vue\")\n\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!./../../node_modules/vux-loader/src/script-loader.js!../../node_modules/vue-loader/lib/selector?type=script&index=0!./Map.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-e61a7770\\\"}!./../../node_modules/vux-loader/src/template-loader.js!../../node_modules/vue-loader/lib/selector?type=template&index=0!./Map.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/Map.vue\n// module id = 366\n// module chunks = 6","//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\nimport { mapState, mapMutations, mapGetters } from 'vuex'\nimport locateControl from 'leaflet.locatecontrol'\n\nexport default {\n    data() {\n        return {\n            zoom: 9,\n            minZoom: 1,\n            maxZoom: 18,\n            url: 'http://{s}.tile.osm.org/{z}/{x}/{y}.png',\n            attribution: 'brandon.xiang',\n            title: 'test-marker',\n            opacity: 1,\n            draggable: false,\n            attributionControl: false,\n        };\n    },\n\n    computed: {\n        ...mapGetters([\n            'center',\n            'cityName',\n        ])\n    },\n\n    mounted() {\n        this.SET_TITLE(this.$t('Map'))\n        this.SET_RIGHT_OPTION({ show: true, name: '城市', link: 'cities/map' })\n        this.addControl(new locateControl())\n    },\n\n    methods: {\n        ...mapMutations(['SET_TITLE', 'SET_RIGHT_OPTION', 'addControl'])\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/views/Map.vue","exports = module.exports = require(\"../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".leaflet-control-locate a{font-size:1.4em;color:#444;cursor:pointer}.leaflet-control-locate.active a{color:#2074b6}.leaflet-control-locate.active.following a{color:#fc8428}\", \"\", {\"version\":3,\"sources\":[\"/Users/brandonxiang/github/vue-leaflet-mobile/node_modules/leaflet.locatecontrol/dist/L.Control.Locate.css\"],\"names\":[],\"mappings\":\"AACA,0BACE,gBAAiB,AACjB,WAAY,AACZ,cAAgB,CACjB,AACD,iCACE,aAAe,CAChB,AACD,2CACE,aAAe,CAChB\",\"file\":\"L.Control.Locate.css\",\"sourcesContent\":[\"/* Compatible with Leaflet 0.7 */\\n.leaflet-control-locate a {\\n  font-size: 1.4em;\\n  color: #444;\\n  cursor: pointer;\\n}\\n.leaflet-control-locate.active a {\\n  color: #2074B6;\\n}\\n.leaflet-control-locate.active.following a {\\n  color: #FC8428;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/leaflet.locatecontrol/dist/L.Control.Locate.css\n// module id = 469\n// module chunks = 6","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\nexports.push([module.id, \"@import url(https://cdn.bootcss.com/leaflet/1.0.3/leaflet.css);\", \"\"]);\nexports.i(require(\"-!../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!leaflet.locatecontrol/dist/L.Control.Locate.css\"), \"\");\nexports.push([module.id, \"@import url(//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css);\", \"\"]);\n\n// module\nexports.push([module.id, \"#map{width:100%;height:100%}\", \"\", {\"version\":3,\"sources\":[\"/Users/brandonxiang/github/vue-leaflet-mobile/src/views/Map.vue\"],\"names\":[],\"mappings\":\"AAIA,KACI,WAAY,AACZ,WAAa,CAChB\",\"file\":\"Map.vue\",\"sourcesContent\":[\"\\n@import \\\"https://cdn.bootcss.com/leaflet/1.0.3/leaflet.css\\\";\\n@import \\\"~leaflet.locatecontrol/dist/L.Control.Locate.css\\\";\\n@import \\\"//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css\\\";\\n#map {\\n    width: 100%;\\n    height: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"id\":\"data-v-e61a7770\",\"scoped\":false,\"hasInlineConfig\":false}!./~/vux-loader/src/style-loader.js!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/views/Map.vue\n// module id = 481\n// module chunks = 6","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"id\\\":\\\"data-v-e61a7770\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../node_modules/vux-loader/src/style-loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Map.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"5857b9b2\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"id\":\"data-v-e61a7770\",\"scoped\":false,\"hasInlineConfig\":false}!./~/vux-loader/src/style-loader.js!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/views/Map.vue\n// module id = 496\n// module chunks = 6","/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n(function (factory, window) {\n     // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders\n     // for details on how to structure a leaflet plugin.\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        if (typeof window !== 'undefined' && window.L) {\n            module.exports = factory(L);\n        } else {\n            module.exports = factory(require('leaflet'));\n        }\n    }\n\n    // attach your plugin to the global 'L' variable\n    if (typeof window !== 'undefined' && window.L){\n        window.L.Control.Locate = factory(L);\n    }\n} (function (L) {\n    var LocateControl = L.Control.extend({\n        options: {\n            /** Position of the control */\n            position: 'topleft',\n            /** The layer that the user's location should be drawn on. By default creates a new layer. */\n            layer: undefined,\n            /**\n             * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n             * While the map is following the user's location, the control is in the `following` state,\n             * which changes the style of the control and the circle marker.\n             *\n             * Possible values:\n             *  - false: never updates the map view when location changes.\n             *  - 'once': set the view when the location is first determined\n             *  - 'always': always updates the map view when location changes.\n             *              The map view follows the users location.\n             *  - 'untilPan': (default) like 'always', except stops updating the\n             *                view if the user has manually panned the map.\n             *                The map view follows the users location until she pans.\n             */\n            setView: 'untilPan',\n            /** Keep the current map zoom level when setting the view and only pan. */\n            keepCurrentZoomLevel: false,\n            /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n            flyTo: false,\n            /**\n             * The user location can be inside and outside the current view when the user clicks on the\n             * control that is already active. Both cases can be configures separately.\n             * Possible values are:\n             *  - 'setView': zoom and pan to the current location\n             *  - 'stop': stop locating and remove the location marker\n             */\n            clickBehavior: {\n                /** What should happen if the user clicks on the control while the location is within the current view. */\n                inView: 'stop',\n                /** What should happen if the user clicks on the control while the location is outside the current view. */\n                outOfView: 'setView',\n            },\n            /**\n             * If set, save the map bounds just before centering to the user's\n             * location. When control is disabled, set the view back to the\n             * bounds that were saved.\n             */\n            returnToPrevBounds: false,\n            /**\n             * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n             * until the locate API returns a new location before they see where they are again.\n             */\n            cacheLocation: true,\n            /** If set, a circle that shows the location accuracy is drawn. */\n            drawCircle: true,\n            /** If set, the marker at the users' location is drawn. */\n            drawMarker: true,\n            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n            markerClass: L.CircleMarker,\n            /** Accuracy circle style properties. */\n            circleStyle: {\n                color: '#136AEC',\n                fillColor: '#136AEC',\n                fillOpacity: 0.15,\n                weight: 2,\n                opacity: 0.5\n            },\n            /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n            markerStyle: {\n                color: '#136AEC',\n                fillColor: '#2A93EE',\n                fillOpacity: 0.7,\n                weight: 2,\n                opacity: 0.9,\n                radius: 5\n            },\n            /**\n             * Changes to accuracy circle and inner marker while following.\n             * It is only necessary to provide the properties that should change.\n             */\n            followCircleStyle: {},\n            followMarkerStyle: {\n                // color: '#FFA500',\n                // fillColor: '#FFB000'\n            },\n            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n            icon: 'fa fa-map-marker',\n            iconLoading: 'fa fa-spinner fa-spin',\n            /** The element to be created for icons. For example span or i */\n            iconElementTag: 'span',\n            /** Padding around the accuracy circle. */\n            circlePadding: [0, 0],\n            /** Use metric units. */\n            metric: true,\n            /** This event is called in case of any location error that is not a time out error. */\n            onLocationError: function(err, control) {\n                alert(err.message);\n            },\n            /**\n             * This even is called when the user's location is outside the bounds set on the map.\n             * The event is called repeatedly when the location changes.\n             */\n            onLocationOutsideMapBounds: function(control) {\n                control.stop();\n                alert(control.options.strings.outsideMapBoundsMsg);\n            },\n            /** Display a pop-up when the user click on the inner marker. */\n            showPopup: true,\n            strings: {\n                title: \"Show me where I am\",\n                metersUnit: \"meters\",\n                feetUnit: \"feet\",\n                popup: \"You are within {distance} {unit} from this point\",\n                outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n            },\n            /** The default options passed to leaflets locate method. */\n            locateOptions: {\n                maxZoom: Infinity,\n                watch: true,  // if you overwrite this, visualization cannot be updated\n                setView: false // have to set this to false because we have to\n                               // do setView manually\n            }\n        },\n\n        initialize: function (options) {\n            // set default options if nothing is set (merge one step deep)\n            for (var i in options) {\n                if (typeof this.options[i] === 'object') {\n                    L.extend(this.options[i], options[i]);\n                } else {\n                    this.options[i] = options[i];\n                }\n            }\n\n            // extend the follow marker style and circle from the normal style\n            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);\n        },\n\n        /**\n         * Add control to map. Returns the container for the control.\n         */\n        onAdd: function (map) {\n            var container = L.DomUtil.create('div',\n                'leaflet-control-locate leaflet-bar leaflet-control');\n\n            this._layer = this.options.layer || new L.LayerGroup();\n            this._layer.addTo(map);\n            this._event = undefined;\n            this._prevBounds = null;\n\n            this._link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);\n            this._link.title = this.options.strings.title;\n            this._icon = L.DomUtil.create(this.options.iconElementTag, this.options.icon, this._link);\n\n            L.DomEvent\n                .on(this._link, 'click', L.DomEvent.stopPropagation)\n                .on(this._link, 'click', L.DomEvent.preventDefault)\n                .on(this._link, 'click', this._onClick, this)\n                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);\n\n            this._resetVariables();\n\n            this._map.on('unload', this._unload, this);\n\n            return container;\n        },\n\n        /**\n         * This method is called when the user clicks on the control.\n         */\n        _onClick: function() {\n            this._justClicked = true;\n            this._userPanned = false;\n\n            if (this._active && !this._event) {\n                // click while requesting\n                this.stop();\n            } else if (this._active && this._event !== undefined) {\n                var behavior = this._map.getBounds().contains(this._event.latlng) ?\n                    this.options.clickBehavior.inView : this.options.clickBehavior.outOfView;\n                switch (behavior) {\n                    case 'setView':\n                        this.setView();\n                        break;\n                    case 'stop':\n                        this.stop();\n                        if (this.options.returnToPrevBounds) {\n                            var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n                            f.bind(this._map)(this._prevBounds);\n                        }\n                        break;\n                }\n            } else {\n                if (this.options.returnToPrevBounds) {\n                  this._prevBounds = this._map.getBounds();\n                }\n                this.start();\n            }\n\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Starts the plugin:\n         * - activates the engine\n         * - draws the marker (if coordinates available)\n         */\n        start: function() {\n            this._activate();\n\n            if (this._event) {\n                this._drawMarker(this._map);\n\n                // if we already have a location but the user clicked on the control\n                if (this.options.setView) {\n                    this.setView();\n                }\n            }\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Stops the plugin:\n         * - deactivates the engine\n         * - reinitializes the button\n         * - removes the marker\n         */\n        stop: function() {\n            this._deactivate();\n\n            this._cleanClasses();\n            this._resetVariables();\n\n            this._removeMarker();\n        },\n\n        /**\n         * This method launches the location engine.\n         * It is called before the marker is updated,\n         * event if it does not mean that the event will be ready.\n         *\n         * Override it if you want to add more functionalities.\n         * It should set the this._active to true and do nothing if\n         * this._active is true.\n         */\n        _activate: function() {\n            if (!this._active) {\n                this._map.locate(this.options.locateOptions);\n                this._active = true;\n\n                // bind event listeners\n                this._map.on('locationfound', this._onLocationFound, this);\n                this._map.on('locationerror', this._onLocationError, this);\n                this._map.on('dragstart', this._onDrag, this);\n            }\n        },\n\n        /**\n         * Called to stop the location engine.\n         *\n         * Override it to shutdown any functionalities you added on start.\n         */\n        _deactivate: function() {\n            this._map.stopLocate();\n            this._active = false;\n\n            if (!this.options.cacheLocation) {\n                this._event = undefined;\n            }\n\n            // unbind event listeners\n            this._map.off('locationfound', this._onLocationFound, this);\n            this._map.off('locationerror', this._onLocationError, this);\n            this._map.off('dragstart', this._onDrag, this);\n        },\n\n        /**\n         * Zoom (unless we should keep the zoom level) and an to the current view.\n         */\n        setView: function() {\n            this._drawMarker();\n            if (this._isOutsideMapBounds()) {\n                this._event = undefined;  // clear the current location so we can get back into the bounds\n                this.options.onLocationOutsideMapBounds(this);\n            } else {\n                if (this.options.keepCurrentZoomLevel) {\n                    var f = this.options.flyTo ? this._map.flyTo : this._map.panTo;\n                    f.bind(this._map)([this._event.latitude, this._event.longitude]);\n                } else {\n                    var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n                    f.bind(this._map)(this._event.bounds, {\n                        padding: this.options.circlePadding,\n                        maxZoom: this.options.locateOptions.maxZoom\n                    });\n                }\n            }\n        },\n\n        /**\n         * Draw the marker and accuracy circle on the map.\n         *\n         * Uses the event retrieved from onLocationFound from the map.\n         */\n        _drawMarker: function() {\n            if (this._event.accuracy === undefined) {\n                this._event.accuracy = 0;\n            }\n\n            var radius = this._event.accuracy;\n            var latlng = this._event.latlng;\n\n            // circle with the radius of the location's accuracy\n            if (this.options.drawCircle) {\n                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n                if (!this._circle) {\n                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);\n                } else {\n                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n                }\n            }\n\n            var distance, unit;\n            if (this.options.metric) {\n                distance = radius.toFixed(0);\n                unit =  this.options.strings.metersUnit;\n            } else {\n                distance = (radius * 3.2808399).toFixed(0);\n                unit = this.options.strings.feetUnit;\n            }\n\n            // small inner marker\n            if (this.options.drawMarker) {\n                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n                if (!this._marker) {\n                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n                } else {\n                    this._marker.setLatLng(latlng);\n                    // If the markerClass can be updated with setStyle, update it.\n                    if (this._marker.setStyle) {\n                        this._marker.setStyle(mStyle);\n                    }\n                }\n            }\n\n            var t = this.options.strings.popup;\n            if (this.options.showPopup && t && this._marker) {\n                this._marker\n                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))\n                    ._popup.setLatLng(latlng);\n            }\n        },\n\n        /**\n         * Remove the marker from map.\n         */\n        _removeMarker: function() {\n            this._layer.clearLayers();\n            this._marker = undefined;\n            this._circle = undefined;\n        },\n\n        /**\n         * Unload the plugin and all event listeners.\n         * Kind of the opposite of onAdd.\n         */\n        _unload: function() {\n            this.stop();\n            this._map.off('unload', this._unload, this);\n        },\n\n        /**\n         * Calls deactivate and dispatches an error.\n         */\n        _onLocationError: function(err) {\n            // ignore time out error if the location is watched\n            if (err.code == 3 && this.options.locateOptions.watch) {\n                return;\n            }\n\n            this.stop();\n            this.options.onLocationError(err, this);\n        },\n\n        /**\n         * Stores the received event and updates the marker.\n         */\n        _onLocationFound: function(e) {\n            // no need to do anything if the location has not changed\n            if (this._event &&\n                (this._event.latlng.lat === e.latlng.lat &&\n                 this._event.latlng.lng === e.latlng.lng &&\n                     this._event.accuracy === e.accuracy)) {\n                return;\n            }\n\n            if (!this._active) {\n                // we may have a stray event\n                return;\n            }\n\n            this._event = e;\n\n            this._drawMarker();\n            this._updateContainerStyle();\n\n            switch (this.options.setView) {\n                case 'once':\n                    if (this._justClicked) {\n                        this.setView();\n                    }\n                    break;\n                case 'untilPan':\n                    if (!this._userPanned) {\n                        this.setView();\n                    }\n                    break;\n                case 'always':\n                    this.setView();\n                    break;\n                case false:\n                    // don't set the view\n                    break;\n            }\n\n            this._justClicked = false;\n        },\n\n        /**\n         * When the user drags. Need a separate even so we can bind and unbind even listeners.\n         */\n        _onDrag: function() {\n            // only react to drags once we have a location\n            if (this._event) {\n                this._userPanned = true;\n                this._updateContainerStyle();\n                this._drawMarker();\n            }\n        },\n\n        /**\n         * Compute whether the map is following the user location with pan and zoom.\n         */\n        _isFollowing: function() {\n            if (!this._active) {\n                return false;\n            }\n\n            if (this.options.setView === 'always') {\n                return true;\n            } else if (this.options.setView === 'untilPan') {\n                return !this._userPanned;\n            }\n        },\n\n        /**\n         * Check if location is in map bounds\n         */\n        _isOutsideMapBounds: function() {\n            if (this._event === undefined) {\n                return false;\n            }\n            return this._map.options.maxBounds &&\n                !this._map.options.maxBounds.contains(this._event.latlng);\n        },\n\n        /**\n         * Toggles button class between following and active.\n         */\n        _updateContainerStyle: function() {\n            if (!this._container) {\n                return;\n            }\n\n            if (this._active && !this._event) {\n                // active but don't have a location yet\n                this._setClasses('requesting');\n            } else if (this._isFollowing()) {\n                this._setClasses('following');\n            } else if (this._active) {\n                this._setClasses('active');\n            } else {\n                this._cleanClasses();\n            }\n        },\n\n        /**\n         * Sets the CSS classes for the state.\n         */\n        _setClasses: function(state) {\n            if (state == 'requesting') {\n                L.DomUtil.removeClasses(this._container, \"active following\");\n                L.DomUtil.addClasses(this._container, \"requesting\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.icon);\n                L.DomUtil.addClasses(this._icon, this.options.iconLoading);\n            } else if (state == 'active') {\n                L.DomUtil.removeClasses(this._container, \"requesting following\");\n                L.DomUtil.addClasses(this._container, \"active\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            } else if (state == 'following') {\n                L.DomUtil.removeClasses(this._container, \"requesting\");\n                L.DomUtil.addClasses(this._container, \"active following\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            }\n        },\n\n        /**\n         * Removes all classes from button.\n         */\n        _cleanClasses: function() {\n            L.DomUtil.removeClass(this._container, \"requesting\");\n            L.DomUtil.removeClass(this._container, \"active\");\n            L.DomUtil.removeClass(this._container, \"following\");\n\n            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n            L.DomUtil.addClasses(this._icon, this.options.icon);\n        },\n\n        /**\n         * Reinitializes state variables.\n         */\n        _resetVariables: function() {\n            // whether locate is active or not\n            this._active = false;\n\n            // true if the control was clicked for the first time\n            // we need this so we can pan and zoom once we have the location\n            this._justClicked = false;\n\n            // true if the user has panned the map after clicking the control\n            this._userPanned = false;\n        }\n    });\n\n    L.control.locate = function (options) {\n        return new L.Control.Locate(options);\n    };\n\n    (function(){\n      // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once\n      // Let's create a wrapper on it which fixes it.\n      var LDomUtilApplyClassesMethod = function(method, element, classNames) {\n        classNames = classNames.split(' ');\n        classNames.forEach(function(className) {\n            L.DomUtil[method].call(this, element, className);\n        });\n      };\n\n      L.DomUtil.addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };\n      L.DomUtil.removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };\n    })();\n\n    return LocateControl;\n}, window));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/leaflet.locatecontrol/src/L.Control.Locate.js\n// module id = 499\n// module chunks = 6","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"full-height\"\n  }, [_c('l-map', {\n    attrs: {\n      \"zoom\": _vm.zoom,\n      \"center\": _vm.center,\n      \"min-zoom\": _vm.minZoom,\n      \"max-zoom\": _vm.maxZoom,\n      \"attributionControl\": _vm.attributionControl\n    }\n  }, [_c('l-tilelayer', {\n    attrs: {\n      \"url\": _vm.url,\n      \"attribution\": _vm.attribution\n    }\n  }), _vm._v(\" \"), _c('l-marker', {\n    attrs: {\n      \"position\": _vm.center,\n      \"title\": _vm.$t(_vm.cityName),\n      \"opacity\": _vm.opacity,\n      \"draggable\": _vm.draggable\n    }\n  }, [_c('l-popup', {\n    attrs: {\n      \"content\": _vm.$t(_vm.cityName)\n    }\n  })], 1)], 1)], 1)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-e61a7770\"}!./~/vux-loader/src/template-loader.js!./~/vue-loader/lib/selector.js?type=template&index=0!./src/views/Map.vue\n// module id = 565\n// module chunks = 6"],"sourceRoot":""}